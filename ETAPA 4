"""
================================================================================
ETAPA 4 - CÁLCULO DE NECESSIDADE DE COMPRA (PEDIDO)
================================================================================
Este script calcula a necessidade de compra (PEDIDO) para cada SKU/CD,
garantindo que o ESTOQUE PROJETADO seja >= ESTOQUE OBJETIVO em todos os meses.

-----------------------------------------------------------------------------
LÓGICA DE CÁLCULO (Atualizada):
-----------------------------------------------------------------------------
ESTOQUE OBJETIVO = (Forward-Looking) Soma a demanda diária futura exata 
                   para os próximos (LT + FREQUENCIA + EST_SEGURANCA) dias.
PEDIDO = Quantidade a pedir no mês para garantir EST_OBJ no mês de chegada.
ENTRADA = Pedidos que CHEGAM no mês (baseado na data do pedido + LT).
ESTOQUE PROJETADO = Est.Anterior + Entrada - Sell Out.

-----------------------------------------------------------------------------
REGRA DE CHEGADA E CALENDÁRIO:
-----------------------------------------------------------------------------
- Mês 0 (Atual): Data de Pedido = Data de Hoje (Data Referência).
- Mês 1 em diante: Data de Pedido = 1º dia do mês.
- Data Chegada = Data do Pedido + LT dias.

================================================================================
"""

import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from dateutil.relativedelta import relativedelta
from openpyxl import Workbook
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
from openpyxl.utils import get_column_letter
import time

try:
    from tqdm import tqdm
except ImportError:
    def tqdm(iterable, **kwargs):
        return iterable

# =============================================================================
# CONFIGURAÇÕES - ALTERAR CONFORME NECESSÁRIO
# =============================================================================

PATH_PREVISAO_SKU = r"\\files\Setores\SupplyChain\Forecast Fornecedores\2026\Teste Automatizado\ETAPA_3_PREVISAO_SKU.xlsx"
PATH_ESTOQUE = r"\\files\Setores\SupplyChain\Forecast Fornecedores\2026\Teste Automatizado\FONTE_ESTOQUE.xlsx"
PATH_OUTPUT = r"\\files\Setores\SupplyChain\Forecast Fornecedores\2026\Teste Automatizado\ETAPA_4_NECESSIDADE_COMPRA.xlsx"

# Parâmetros de cálculo
DIAS_MES = 30  # Dias do mês padronizado para cálculo de demanda
HORIZONTE_MESES = 13  # Mês atual + 12 meses futuros
DATA_REFERENCIA = datetime.now()  # Data de execução do script


# =============================================================================
# FUNÇÕES AUXILIARES
# =============================================================================

def calcular_dias_restantes_mes(data_ref):
    """Calcula quantos dias restam no mês atual."""
    ultimo_dia = (data_ref.replace(day=1) + relativedelta(months=1) - timedelta(days=1)).day
    dias_restantes = ultimo_dia - data_ref.day + 1
    return dias_restantes, ultimo_dia


def gerar_lista_meses(data_ref, horizonte):
    """Gera lista de meses no formato YYYY_MM a partir da data de referência."""
    meses = []
    for i in range(horizonte):
        mes = data_ref + relativedelta(months=i)
        meses.append(mes.strftime("%Y_%m"))
    return meses


def calcular_mes_chegada(data_pedido, lt_dias):
    """Calcula o mês de chegada baseado na data do pedido e Lead Time."""
    try:
        lt = int(float(lt_dias)) if pd.notna(lt_dias) else 0
    except:
        lt = 0
    data_chegada = data_pedido + timedelta(days=lt)
    return data_chegada.strftime("%Y_%m")


def safe_numeric(val, default=0):
    """Converte valor para numérico de forma segura."""
    try:
        if pd.isna(val):
            return default
        if isinstance(val, str):
            val = val.strip()
            if val.lower() in ['(vazio)', 'vazio', '', 'nan', 'none']:
                return default
        return float(val)
    except:
        return default


# =============================================================================
# FUNÇÃO PRINCIPAL
# =============================================================================

def main():
    print("=" * 70)
    print("ETAPA 4 - CÁLCULO DE NECESSIDADE DE COMPRA (PEDIDO)")
    print("⚠️ VERSÃO: OTIMIZADA + DRP CONTÍNUO (MÊS A MÊS)")
    print("=" * 70)

    # -------------------------------------------------------------------------
    # 1. CARREGAR DADOS
    # -------------------------------------------------------------------------
    print("\n[1] Carregando arquivos...")
    try:
        start_load = time.time()
        df_previsao = pd.read_excel(PATH_PREVISAO_SKU)
        df_estoque = pd.read_excel(PATH_ESTOQUE)
        print(f"    ✓ Arquivos carregados em {time.time() - start_load:.2f} segundos.")
    except FileNotFoundError as e:
        print(f"\n❌ ERRO: Arquivo não encontrado!")
        print(f"   {e}")
        return

    print(f"    - Previsão SKU: {df_previsao.shape[0]:,} linhas")
    print(f"    - Estoque: {df_estoque.shape[0]:,} linhas")

    # -------------------------------------------------------------------------
    # 2. PREPARAR PARÂMETROS TEMPORAIS
    # -------------------------------------------------------------------------
    meses_horizonte = gerar_lista_meses(DATA_REFERENCIA, HORIZONTE_MESES)
    meses_horizonte_ext = gerar_lista_meses(DATA_REFERENCIA, HORIZONTE_MESES + 6) 

    dias_restantes, dias_total = calcular_dias_restantes_mes(DATA_REFERENCIA)
    proporcao_mes_atual = dias_restantes / dias_total

    print(f"\n[2] Parâmetros temporais:")
    print(f"    - Data referência: {DATA_REFERENCIA.strftime('%d/%m/%Y')}")
    print(f"    - Dias restantes no mês: {dias_restantes} de {dias_total} ({proporcao_mes_atual:.1%})")

    # -------------------------------------------------------------------------
    # 3. PREPARAR DADOS DE ESTOQUE E PREVISÃO
    # -------------------------------------------------------------------------
    print("\n[3] Preparando dados...")
    df_estoque = df_estoque.rename(columns={
        'ESTOQUE ATUAL': 'ESTOQUE',
        'LT (DIAS)': 'LT',
        'FREQUENCIA (DIAS)': 'FREQUENCIA',
        'ESTOQUE DE SEGURANÇA (DIAS)': 'EST_SEGURANCA'
    })

    for col in ['ESTOQUE', 'PENDENCIA', 'NNA', 'LT', 'FREQUENCIA', 'EST_SEGURANCA']:
        df_estoque[col] = df_estoque[col].apply(safe_numeric)

    meses_necessarios = set(meses_horizonte_ext)
    df_prev_filtrado = df_previsao[df_previsao['ano_mes'].isin(meses_necessarios)]

    df_pivot = df_prev_filtrado.pivot_table(
        index=['codigo_deposito_pd', 'codigo_produto'],
        columns='ano_mes', values='Previsao_Vendas', aggfunc='sum', fill_value=0
    ).reset_index()

    df_cadastro = df_previsao.groupby(['codigo_deposito_pd', 'codigo_produto']).agg({
        'nome produto': 'first', 'fornecedor comercial': 'first',
        'nome nível 3': 'first', 'nome nível 4': 'first', 'situacao': 'first'
    }).reset_index()

    df_pivot = df_pivot.merge(df_cadastro, on=['codigo_deposito_pd', 'codigo_produto'], how='left')
    
    df = df_pivot.merge(
        df_estoque[['codigo_deposito_pd', 'codigo_produto', 'ESTOQUE', 'PENDENCIA', 'NNA', 'LT', 'FREQUENCIA', 'EST_SEGURANCA']],
        on=['codigo_deposito_pd', 'codigo_produto'], how='inner'
    )
    df['CHAVE'] = df['codigo_deposito_pd'].astype(str) + '-' + df['codigo_produto'].astype(str)

    if df.shape[0] == 0:
        print("\n❌ ERRO: Nenhum registro encontrado após merge!")
        return

    # -------------------------------------------------------------------------
    # 4. PRÉ-CÁLCULO E CACHE DE CALENDÁRIO OTIMIZADO
    # -------------------------------------------------------------------------
    meses_ext_idx = {m: i for i, m in enumerate(meses_horizonte_ext)}
    
    # Pre-compute data de pedido simulada no horizonte
    datas_pedido_por_t = []
    for t in range(HORIZONTE_MESES):
        if t == 0:
            datas_pedido_por_t.append(DATA_REFERENCIA)
        else:
            datas_pedido_por_t.append((DATA_REFERENCIA + relativedelta(months=t)).replace(day=1))
            
    # Cache para `calcular_mes_chegada`
    cache_chegada = {}
    def fast_mes_chegada(data_pedido, lt_dias):
        key = (data_pedido, lt_dias)
        if key not in cache_chegada:
             cache_chegada[key] = calcular_mes_chegada(data_pedido, lt_dias)
        return cache_chegada[key]
        
    df_records = df.to_dict('records')
    linhas_output = []

    # -------------------------------------------------------------------------
    # 5. CALCULAR NECESSIDADE DE COMPRA (DRP CONTÍNUO E FORWARD-LOOKING)
    # -------------------------------------------------------------------------
    print("\n[4] Calculando simulação DRP Mês a Mês...")
    
    for row in tqdm(df_records, desc="Processando SKUs"):
        cadastro = {
            'fornecedor comercial': row.get('fornecedor comercial', ''),
            'situacao': row.get('situacao', ''), 'CHAVE': row['CHAVE'],
            'codigo_deposito_pd': row['codigo_deposito_pd'], 'codigo_produto': row['codigo_produto'],
            'nome produto': row.get('nome produto', ''), 'nome nível 3': row.get('nome nível 3', ''),
            'nome nível 4': row.get('nome nível 4', ''), 'ESTOQUE': row['ESTOQUE'],
            'PENDENCIA': row['PENDENCIA'], 'LT': row['LT'], 'NNA': row['NNA'],
            'FREQUENCIA': row['FREQUENCIA'], 'EST_SEGURANCA': row['EST_SEGURANCA']
        }

        estoque_atual = safe_numeric(row['ESTOQUE'])
        pendencia = safe_numeric(row['PENDENCIA'])
        nna = safe_numeric(row['NNA'])
        lt = safe_numeric(row['LT'])
        frequencia = safe_numeric(row['FREQUENCIA'])
        est_seguranca = safe_numeric(row['EST_SEGURANCA'])

        estoque_inicial = estoque_atual + pendencia + nna
        dias_cobertura = lt + frequencia + est_seguranca

        # 1. Calcular SELL_OUT e EST_OBJ por índice via listas rápidas
        est_obj_por_mes = [0.0] * len(meses_horizonte_ext)
        sell_out_por_mes = [0.0] * len(meses_horizonte_ext)

        for i, mes in enumerate(meses_horizonte_ext):
            so = safe_numeric(row.get(mes, 0))
            if i == 0:
                so = so * proporcao_mes_atual
            sell_out_por_mes[i] = so

            dias_rest = dias_cobertura
            demanda_forward = 0.0
            
            for j in range(i, len(meses_horizonte_ext)):
                demanda_futura = safe_numeric(row.get(meses_horizonte_ext[j], 0))
                
                if dias_rest >= DIAS_MES:
                    demanda_forward += demanda_futura
                    dias_rest -= DIAS_MES
                else:
                    demanda_forward += demanda_futura * (dias_rest / DIAS_MES)
                    dias_rest = 0
                    break
                    
            if dias_rest > 0:
                ultimo_mes_disp = meses_horizonte_ext[-1]
                demanda_ult = safe_numeric(row.get(ultimo_mes_disp, 0))
                demanda_forward += (demanda_ult / DIAS_MES) * dias_rest
                
            est_obj_por_mes[i] = demanda_forward

        # 2. Mapear o índice de chegada considerando o LT
        idx_chegada_por_t = []
        for t in range(HORIZONTE_MESES):
            data_pedido = datas_pedido_por_t[t]
            m_chegada = fast_mes_chegada(data_pedido, lt)
            if m_chegada in meses_ext_idx:
                idx_chegada_por_t.append(meses_ext_idx[m_chegada])
            else:
                idx_chegada_por_t.append(len(meses_horizonte_ext) + 999)

        # 3. Simulate MRP/DRP (Fluxo Linear)
        pedidos = [0.0] * HORIZONTE_MESES
        entradas = [0.0] * len(meses_horizonte_ext)
        
        for t in range(HORIZONTE_MESES):
            idx_atual = idx_chegada_por_t[t]
            
            # Se a encomenda já passar do nosso horizonte estendido, ignora o cálculo
            if idx_atual >= len(meses_horizonte_ext):
                continue
                
            idx_prox = idx_chegada_por_t[t+1] if t + 1 < HORIZONTE_MESES else idx_atual + 1
            idx_fim = max(idx_atual, idx_prox - 1)
            
            necessidade_t = 0.0
            
            # Garanto os meses no alcance deste pedido
            for k in range(idx_atual, idx_fim + 1):
                if k >= len(meses_horizonte_ext):
                    continue
                    
                # Estoque projetado acumulado até k 
                proj_inv_k = estoque_inicial + sum(entradas[:k+1]) - sum(sell_out_por_mes[:k+1]) + necessidade_t
                
                obj_k = est_obj_por_mes[k]
                if proj_inv_k < obj_k:
                    req = obj_k - proj_inv_k
                    necessidade_t += req
                    
            if necessidade_t > 0:
                pedidos[t] += necessidade_t
                entradas[idx_atual] += necessidade_t

        # 4. Consolidar Resultados
        estoque_atual_simul = estoque_inicial
        for t in range(HORIZONTE_MESES):
            mes = meses_horizonte[t]
            sell_out = sell_out_por_mes[t]
            entrada_mes = entradas[t]
            est_proj = estoque_atual_simul + entrada_mes - sell_out

            linha = cadastro.copy()
            linha.update({
                'MES_ANO': mes,
                'SELL_OUT': round(sell_out, 0),
                'ESTOQUE_PROJETADO': round(est_proj, 0),
                'ESTOQUE_OBJETIVO': round(est_obj_por_mes[t], 0),
                'PEDIDO': round(pedidos[t], 0),
                'ENTRADA': round(entrada_mes, 0)
            })
            linhas_output.append(linha)
            estoque_atual_simul = est_proj

    # -------------------------------------------------------------------------
    # 6. EXPORTAR PARA EXCEL OTIMIZADO
    # -------------------------------------------------------------------------
    print("\n[5] Exportando para Excel...")
    df_output = pd.DataFrame(linhas_output)
    colunas_ordem = [
        'fornecedor comercial', 'situacao', 'CHAVE', 'codigo_deposito_pd',
        'codigo_produto', 'nome produto', 'nome nível 3', 'nome nível 4',
        'ESTOQUE', 'PENDENCIA', 'LT', 'NNA', 'FREQUENCIA', 'EST_SEGURANCA',
        'MES_ANO', 'SELL_OUT', 'ESTOQUE_PROJETADO', 'ESTOQUE_OBJETIVO', 'PEDIDO', 'ENTRADA'
    ]
    df_output = df_output[colunas_ordem]

    start_export = time.time()
    with pd.ExcelWriter(PATH_OUTPUT, engine='openpyxl') as writer:
        df_output.to_excel(writer, sheet_name="Necessidade_Compra", index=False)
        worksheet = writer.sheets["Necessidade_Compra"]

        # Formatações Visuais - Cabeçalho
        header_fill = PatternFill('solid', fgColor='366092')
        header_font = Font(bold=True, color='FFFFFF')
        border = Border(left=Side(style='thin'), right=Side(style='thin'), top=Side(style='thin'), bottom=Side(style='thin'))

        for cell in worksheet[1]:
            cell.fill = header_fill
            cell.font = header_font
            cell.alignment = Alignment(horizontal='center')
            cell.border = border

        # Define colunas numéricas
        numeric_cols_idx = {i + 1 for i, col in enumerate(df_output.columns) 
                            if col in ['SELL_OUT', 'ESTOQUE_PROJETADO', 'ESTOQUE_OBJETIVO', 'PEDIDO', 'ENTRADA', 'ESTOQUE', 'PENDENCIA', 'LT', 'NNA', 'FREQUENCIA', 'EST_SEGURANCA']}

        # Formatação rápida das células (muito mais veloz que iterar sobre linhas no pandas)
        for row in worksheet.iter_rows(min_row=2, max_row=worksheet.max_row, min_col=1, max_col=worksheet.max_column):
            for cell in row:
                cell.border = border
                if cell.column in numeric_cols_idx:
                    cell.number_format = '#,##0'

        # Ajuste de larguras
        widths = [18, 8, 12, 6, 10, 35, 18, 20, 10, 10, 6, 6, 10, 10, 10, 12, 15, 15, 12, 12]
        for col_idx, width in enumerate(widths, 1):
            col_letter = get_column_letter(col_idx)
            worksheet.column_dimensions[col_letter].width = width

        worksheet.freeze_panes = 'A2'
        worksheet.auto_filter.ref = worksheet.dimensions

    print(f"    ✓ Arquivo salvo em {time.time() - start_export:.2f} segundos: {PATH_OUTPUT}")
    print("\n" + "=" * 70)
    print("✅ ETAPA 4 CONCLUÍDA COM SUCESSO!")
    print("=" * 70)

if __name__ == "__main__":
    main()
